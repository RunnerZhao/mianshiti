## 算法

- 1.全排列

```javascript
const permute = function (nums) {
    const len = nums.length, res = [], deepStack = [];
    const backtrack = (deepStack) => {
        if (deepStack.length === len) {
            return res.push([...deepStack]);
        }
        for (let i = 0; i < len; i += 1) {
            if (!deepStack.includes(nums[i])) {
                deepStack.push(nums[i]);
                backtrack(deepStack);
                deepStack.pop();
            }
        }
    }
    backtrack(deepStack);
    return res;
}

// 测试
console.log(permute([1, 2, 3]));
```

## 计算机相关

- 1.http2的一些新特性？

>1.http2大幅度的提升了网页的性能。

>2.http2是一个二进制协议，http1是一个超文本协议。

>3.http2遵循多路复用，同一域名下的内容只建立一次连接。

>4.http2会压缩请求头内容，http1不会进行压缩。

>5.http2允许服务器预先将网页所需要的资源PUSH到浏览器内存中。

>缺点，还未解决队头阻塞问题。

- 2.浏览器缓存和http缓存？强缓存和协商缓存请求头的区别？

>1.强缓存是浏览器直接从本地缓存中取数据，如果存在就直接取出来。返回状态码200，这个时候是不会去请求服务器的。

>2.协商缓存是浏览器需要向服务器发请求询问我是否可以用这个缓存，如果服务器返回304表示可以用，如果是200，那就是服务器直接将数据返回回来了。

>强缓存和协商缓存请求头的参数？

>强缓存：expires：过期时间，cache-control

>协商缓存：etag：用来帮助服务器控制web端的缓存验证，if-none-match：资源过期时，像服务器请求时带上这个参数，服务器收到请求进行对比，决定返回200或304。last-modified：浏览器向服务器发送最后修改时间。if-modified-since，再次请求的时候会带上这个属性，然后去比较这个时间和请求资源最后修改时间做对比，若最后修改时间大于这个时间，那么返回最新资源，返回状态码200，若修改时间小于这个时间，说明资源没有修改，返回304.

- 3.websockt原理？

- 4.http1的缺陷？

>1.高延迟，带来页面加载速度降低。

网络延迟的原因是队头阻塞，就是前面请求因为某些原因被阻塞了，后面的请求就只能等待了

- 5.tcp和udp的区别？

>都是传输层协议。

- 6.tcp的3次握手和4次挥手？

>首先3次握手是客户端和服务端建立连接的过程，而4次挥手是客户端和服务端断开连接的过程。tcp/ip协议是一个传输层的安全可靠的协议。

>3次握手过程，1.首先客户端向服务端发起申请连接请求，就相当于告诉服务端，我要跟你连接。2.然后服务端响应这个连接并且给客户端发送一个请求告诉客户端可以进行连接。3.客户端收到这个请求，然后发送一个请求给服务端告诉服务端我知道了，我们可以建立连接。

>4次挥手过程。1.首先客户端发送一个请求给服务端，告诉服务端，我要跟你断开连接。2.然后服务端收到这个请求并响应告诉客户端我收到了你的申请断开的请求，但是我还没准备好，等我准备好了我通知你。3.等服务端准备好了，服务端再发送一个请求给客户端，告诉客户端我准备好了，我们可以断开连接了。4.客户端收到这个请求，然后会再发送一个请求给服务端，告诉服务端我收到了你准备好了的信息，我们可以断开连接了。

>4次挥手的过程，第2次和第3次能不能合并为一次，这个是不能的，因为tcp连接是安全的，所以在通信的过程中需要保证每一步都正确完成了，如果将第2步和第3步合到一起的话，那么在客户端发出断开连接的时候，服务端还有请求在发给客户端，这种情况也是需要处理的，所以服务端需要先准备。就是把一些待发送的请求给它取消掉。

- 7.Tcp/ip协议4层网络模型？

>应用层，传输层，数据链路层，网络层。

## JS

- 1.V8引擎回收机制。

>V8引擎底层是用C++写的。

>参考文章，[V8引擎详细的垃圾回收](https://time.geekbang.org/column/article/131233)

- 1.首先说到垃圾回收，就要说一下JS存储数据的方式，JS中的数据类型其实是分为两类的，一类是原始数据类型，另一类就是引用类型，然后JS中的原始类型是存在栈空间中的，而引用类型是存在堆空间中的，栈空间中存了一个引用地址，然后通过这个引用地址去使用引用类型。然后对于栈空间中的垃圾数据，回收的方法是通过一个ESP指针去移动标识哪些内容是否有用，没用的就直接抹掉。而堆空间中的垃圾回收要比栈空间中的垃圾回收更为复杂，说到堆空间里的垃圾回收，我们先要说一下代际假说，这个假说有两个特点，一个特点是有些对象生存时间很短，在分配内存没多久就变得不可访问了，第二个特点是有些对象会活的很久。在这个假说的基础上，V8进行了垃圾回收的实现。首先V8引擎将堆空间分为新生代区域和老生代区域，然后新生代区域主要存储生存时间短的对象，而老生代区域存储的是生存时间长的对象。然后垃圾回收也通过2个垃圾回收器进行回收，一个副垃圾回收器负责新生代区域的垃圾回收，一个主垃圾回收器负责老生代区域的垃圾回收。新生代区域的垃圾回收，主要是将新生代区域拆分成两个区域，一个对象区域，一个空闲区域，在对象区域中对活动对象进行标记，然后将这些活动对象复制到空闲区域，然后将空闲区域和对象区域反转，然后进行垃圾回收。老生代区域的垃圾回收是通过主垃圾回收器进行的，因为老生代区域里的对象比较大，所以不能像新生代区域那样采用scavenge算法，因为复制活动对象是需要时间的，因为老生代区域里的对象比较大，复制时间会比较长，所以老生代区域采用标记-清除的方法进行垃圾回收，对不活动对象进行标记，然后标记完成之后将不活动对象全部清理掉。但是这种方法会导致内存空间里存在内存碎片，所以还有一种清理方法就是标记-整理的清理方法，基本上跟上一种方法差不多，不过清理的时候，会将活动对象全部放到一端，清除端之外的内存，这样就不存在内存碎片了。然后这里面还有一个机制就是晋升机制，当一个对象在新生代里经过2次垃圾回收还存在的话就会被自动晋升放到老生代区域中。最后就是在执行垃圾回收的过程中，因为JS是单线程运行的，所以进行垃圾回收的时候需要停下js脚本的运行工作，这样如果js垃圾回收时间较长的话，那么JS脚本如果正在执行动画，那就会卡顿，所以V8对将一个垃圾回收过程拆成了很多小的任务，和js脚本穿插执行，这样就不会有卡顿的感觉了，JS的垃圾回收机制基本是这样。

- 2.怎么实现一个迭代器。

- 3.ES6有哪些新属性？

- 4.箭头函数和普通函数的区别？

- 5.js垃圾回收机制？V8内存回收策略？

- 6.事件循环？

- 7.Promise中有哪三种状态？

- 8.JS数据类型？

- 9.跨域，以及各种方法的优缺点？

- 10.原型链，声明一个数组，他的原型链是怎样的？

- 11.for...in和for...of的区别？

- 12.数组对象排序

```javascript
const arr = [{ a: 1, b: 2 }, { a: 0, b: 1 }, { a: 10, b: 11 }];

console.log(arr.sort(function (a, b) {
    return (a.a + a.b) - (b.a + b.b);
}));
```

## CSS

- 1.div间距问题。

- 2.position属性？

>staic、absolute、fixed、relative、syicky

- 3.水平垂直居中？

- 4.flex属性？

- 5.BFC？

## 浏览器

- 1.浏览器渲染页面具体过程。

- 2.浏览器的缓存机制。

- 3.从输入域名到页面展示的过程？

- 4.浏览器渲染页面过程？

## Vue

- 1.Vue双向绑定原理？

- 2.computed和watch的区别？以及改变数据computed变化情况？

- 3.Vue和React的区别？
