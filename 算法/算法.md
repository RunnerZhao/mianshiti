-1.什么是复杂度 1 定义：程序执行时需要的cpu计算量（时间复杂度 -cpu）和内存空间（空间复杂度 -内存） ,-（和代码是否简洁无关） 复杂度是数量级（相差不大的数量范围），不是具体数字 一般针对具体的算法,而非一个完整的系统
2 [时间复杂度图](.算法_images/fdab399b.png)
O(1)一次就够 O（n）和输入的数据量一样（一个for循环） O(n^2)输入的数据量的平方(两个for循环)   O(logn)数据量的对数（以2为底的数据量（n）的对数）二分 O（n*logn) 数据量*数据量的对数
（for循环里面包二分） 3 O(1):有限的、可数的空间 O(n)和输入量相同的空间 -2 数组旋转 1）pop unshift 2）concat -3 单元测试

```javascript
//describe 	美[dɪˈskraɪb]  描述; 形容;  expect 美[ɪkˈspekt] v.	预料; 预期; 预计; 等待; 期待; 盼望; 要求; 指望; 猜想;
// equal 	美[ˈiːkwəl] (在大小、数量、价值、程度、能力等方面)相等的, 同样的; 

describe('测试名字描述', () => {
    it('测试情况1',() => {
    const arr = [1, 2, 3, 4]
    const k = 2
    const res = rotate2(arr, k)
    expect(res).toEqual([3, 4, 1, 2])
});
})
describe('测试名字',()=>{
    it('qingkuang', function () {
        expect(res).toEqual()
    });
})
```
- 数组旋转

```javascript
 //旋转数组 pop unshift  时间复杂度 O(n^2) 空间复杂度O（1）
function rotate1(arr, k) {
    const length = arr.length
    if (!k || length === 0) return arr
    const step = Math.abs(k % length)//取余 取绝对值
    for (let i = 0; i < step; i++) {
        let lastValue = arr.pop()
        arr.unshift(lastValue) //数组是一个有序数组 unshift操作非常慢 时间复杂度是O(n)  ，数组是连续的内存空间
    }
    return arr
}

// slice concat    时间复杂度 O(1) 空间复杂度O（n）
function rotate2(arr, k) {
    const length = arr.length
    if (!k || length === 0) return arr
    const step = Math.abs(k % length)
    const part1 = arr.slice(-step)//O(1)
    const part2 = arr.slice(0, length - step)
    const part3 = part1.concat(part2)
    return part3
}

//功能测试
let array1 = [1, 2, 3]
console.log("11", rotate1(array1, 2))
//性能测试
let arrTest = []
for (let i = 0; i < 10 * 10000; i++) {
    arrTest.push(i)
}
let arrTest2 = []
for (let i = 0; i < 10 * 10000; i++) {
    arrTest2.push(i)
}
console.time('rotate1')
rotate1(arrTest, 9 * 10000)  //980.5830078125 ms
console.timeEnd('rotate1')

console.time('rotate2')
rotate2(arrTest2, 9 * 10000) //0.51220703125 ms
console.timeEnd('rotate2')


```

- 二分查找

```javascript
function halfSearch(arr, num) {
    // 1 定义start和end 用来查目标数组段 2 定义中间index middleIndex 3 取中间值middleVal = arr[middleIndex] 
    // 4 while 循环条件中start<end 体中判断middleVale比num小就使end=middleInde+1 ，middleVal比num大就使start = middleIndex-1 ，middleVal等于num就return middleIndex
    let start = 0;
    let end = arr.length - 1;
    while (start < end) {
        let middleIndex = Math.floor((start + end) / 2)
        let middleVal = arr[middleIndex]
        if (middleVal < num) {
            end = middleIndex + 1
        } else if (middleIndex > num) {
            start = middleIndex - 1
        } else if (middleVal == num) {
            return middleIndex
        }
    }
    return -1
}
```

- 找数组中和为n的两个数 双指针 时间复杂度O(n)  优化嵌套循环就用双指针

```javascript
  function findTwoNum(arr, count) {
    //定义start end 作为要找的两个数的下标
    //while循环条件是start<end 循环体中定义两数之和sum = arr[start] + arr[end]
    // 如果sum<count则start往右移动一位即start++  如果sum >count end往左移动一位即end--
    // 如果sum == count return[arr[start],arr[end]]
    let start = 0, end = arr.length - 1;
    while (start < end) {
        console.log('while')
        let sum = arr[start] + arr[end]
        if (sum < count) {
            start++
        } else if (sum > count) {
            end--
        } else {
            return [arr[start], arr[end]]
        }
    }
    return -1
}

const arrSum = [1, 3, 4, 5, 8, 9]
console.log(findTwoNum(arrSum, 11))
```

- 求二叉树的第k小值

> 二叉树：每个节点最多只能有两个子节点 树节点的数据结构{value left？ right？}
> 二叉树的遍历：1 前序遍历：root - >left - >right 中序遍历：left -> root - >right 后序遍历：left -> right ->root
![二叉树的遍历](.算法_images/23dce21f.png)
> 二叉搜索树BST： ![二叉搜索树定义](.算法_images/ca6fe712.png) 目的：为了性能 二分思想 数组查找快增删慢 链表查找慢增删快 二叉搜索树查找增删都快所以性能好
![二叉搜索树](.算法_images/ea8b7198.png)
> 平衡二叉搜索树BBST：BST如果不平衡就成了链表,所以要尽量平衡BBST。 增删查时间复杂度都是O(logn)，即树的高度
> 红黑树：1 一种自平衡二叉树 2 分为 红/黑 两种颜色，通过颜色转换来维持树的平衡 3 相对于普通平衡二叉树，它维持平衡的效率更高 ![红黑树](.算法_images/ab0bd450.png)
> B树：物理上是多叉树 ，但是逻辑上是二叉树 一般用于高效I/O，关系型数据库常用B树来组织数据 ![B树](.算法_images/bba694ee.png)

> 堆（heap）栈（stack 先进后出）模型 ： js代码执行时，值类型变量存储在栈，引用类型变量存储在堆 ! [堆栈模型](.算法_images/ccdf85d4.png)
堆：是一个完全二叉树 。逻辑结构是一颗二叉树 物理结构是一个数组（适合连续存储+节省空间） 。 特点：最大堆：父节点 >= 子节点 ；最小堆：父节点 <= 子节点  ![查找节点值的规则](.算法_images/3bd7f691.png)
完全二叉树：左右两边都填满是满二叉树。左边填满，右边不填满是完全二叉树  ![定义](.算法_images/ec451751.png)
> 堆 vs BST 查询比BST慢 增删比BST快，维持平衡更快 时间复杂度都是O(logn)
> 堆的使用场景：1 特别适合堆栈模型 2堆的数据都是在栈中引用的，不需要从root遍历 3 堆恰巧是数组形式，根据栈的地址，可用O(1)找到目标

- 斐波那契数列 递归 ![大量重复计算](.算法_images/cd17cd30.png)

```javascript
 //fibonacci数列 递归
function fibonacci(n) { //时间复杂度 O(2^n) 重复计算了
    //如果n == 0,return 0 如果n == 1，return 1
    //return fibonacci(n-1) + fibonacci(n-2)
    if (n <= 0) return 0
    if (n === 1) return 1
    return fibonacci(n - 1) + fibonacci(n - 2)
}

console.log('fibonacci', fibonacci(9))
```

//循环 记录中间结果 ![图解](.算法_images/1f7afcc5.png)

```javascript
 //fibonacci数列 循环 记录中间值
function fibonacci1(n) {//
    // 如果n == 0,return 0 如果n == 1，return 1
    //定义 n的前一位数 n1 = 1，n的前两位数 n2 = 0 ，n1 n2的和res=0
    //for循环中 res = n1 + n2   n2 = n1   n1=res
    if (n === 0) return 0
    if (n === 1) return 1
    let n1 = 1, n2 = 0, res = 0;
    for (let i = 2; i <= n; i++) {//从2开始
        res = n1 + n2;
        //记录中间结果
        n2 = n1
        n1 = res
    }
    return res
}

console.log("fibonacci1", fibonacci1(2))

```

动态规划：1 把一个大问题拆解成多个小问题，逐级向下拆解 2 用递归的思路去分析问题，再改为循环来实现 算法三大思维：贪心 、二分、动态规划

- 将数组中的所有0移动到末尾




- 1.题目： 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的 一个二维数组和一个整数，判断数组中是否含有该整数。
  

