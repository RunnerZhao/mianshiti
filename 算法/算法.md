-1.什么是复杂度 1 定义：程序执行时需要的cpu计算量（时间复杂度 -cpu）和内存空间（空间复杂度 -内存） ,-（和代码是否简洁无关） 复杂度是数量级（相差不大的数量范围），不是具体数字 一般针对具体的算法,而非一个完整的系统
2 [时间复杂度图](.算法_images/fdab399b.png)
O(1)一次就够 O（n）和输入的数据量一样（一个for循环） O(n^2)输入的数据量的平方(两个for循环)   O(logn)数据量的对数（以2为底的数据量（n）的对数）二分 O（n*logn) 数据量*数据量的对数
（for循环里面包二分） 3 O(1):有限的、可数的空间 O(n)和输入量相同的空间 -2 数组旋转 1）pop unshift 2）concat -3 单元测试

```javascript
//describe 	美[dɪˈskraɪb]  描述; 形容;  expect 美[ɪkˈspekt] v.	预料; 预期; 预计; 等待; 期待; 盼望; 要求; 指望; 猜想;
// equal 	美[ˈiːkwəl] (在大小、数量、价值、程度、能力等方面)相等的, 同样的; 

describe('测试名字描述', () = {
    it('测试情况1',() = {
    const arr = [1, 2, 3, 4]
    const k = 2
    const res = rotate2(arr, k)
    expect(res).toEqual([3, 4, 1, 2])
});
})

describe('hh', () => {
    it('11', function () {
        expect(res).toEqual([])
    });
})
```

- 二分查找

```javascript
function halfSearch(arr,num){
    // 1 定义start和end 用来查目标数组段 2 定义中间index middleIndex 3 取中间值middleVal = arr[middleIndex] 
    // 4 while 循环条件中start<end 体中判断middleVale比num小就使end=middleInde+1 ，middleVal比num大就使start = middleIndex-1 ，middleVal等于num就return middleIndex
    let start = 0;
    let end = arr.length - 1;
    while (start < end){
        let middleIndex = Math.floor((start + end)/2)
        let middleVal = arr[middleIndex]
        if (middleVal < num){
            end = middleIndex + 1
        }else if (middleIndex > num){
            start = middleIndex -1
        }else if (middleVal == num){
            return middleIndex
        }
    }
    return -1 
}
```
- 找数组中和为n的两个数  双指针 时间复杂度O(n)  优化嵌套循环就用双指针
```javascript
  function findTwoNum(arr, count) {
        //定义start end 作为要找的两个数的下标
        //while循环条件是start<end 循环体中定义两数之和sum = arr[start] + arr[end]
        // 如果sum<count则start往右移动一位即start++  如果sum >count end往左移动一位即end--
        // 如果sum == count return[arr[start],arr[end]]
        let start = 0, end = arr.length - 1;
        while (start < end) {
            console.log('while')
            let sum = arr[start] + arr[end]
            if (sum < count){
                start++
            }else if (sum > count){
                end--
            }else {
                return[arr[start],arr[end]]
            }
        }
        return -1
    }
    const arrSum = [1,3,4,5,8,9]
    console.log(findTwoNum(arrSum,11))
```

- 求二叉树的第k小值
 二叉树：每个节点最多只能有两个子节点 树节点的数据结构{value left？  right？}
  二叉树的遍历：1 前序遍历：root - >left - >right 中序遍历：left -> root - >right 
  后序遍历：left -> right ->root
  ![二叉树的遍历](.算法_images/23dce21f.png)
























- 1.题目： 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的 一个二维数组和一个整数，判断数组中是否含有该整数。
  

