<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        html, body {
            width: 100%;
            height: 100%;

        }

    </style>
</head>

<body>
<h2>
    手写
</h2>
<div id="box">
<!--    注释这是-->
    <span></span>
    <span></span>
    <ul>
        <li>1</li>
        <li>2</li>
    </ul>
</div>


</body>
<script type="text/javascript">
    //数组扁平化 只扁平化一级 多维数组转为一维数组
    //使用push  循环数组，如果item为数组则循环item并把n push到res中 ，如果不为数组则把item push到res中
    function flatten(arr){
        const res  = []
        arr.forEach(item =>{
            if (Array.isArray(item)){
                 item.forEach(n =>{res.push(n)})
            }else{
                res.push(item)
            }
        })
        return res
    }
    const arr1 = [1,2,[3,[4,5]],6]
    // console.log('flatten',flatten(arr1))

    //使用concat
    function flatten1(arr){
        let res = [];
        arr.forEach(item => {
            res = res.concat(item)
        })
        return res;
    }

    console.log('flatten1',flatten1(arr1))

    //单元测试 jest
    // describe('',function (){
    //     it('空数组', function () {
    //         const res = flatten([])
    //         expect(res).toEqual([])
    //     });
    // })


    //数组深度扁平化 彻底拍平 多维数组转为一维数组
    //使用push
    function flattenDeep(arr){
        const res  = []
        arr.forEach(item =>{
            if (Array.isArray(item)){
                const flattenItem = flattenDeep(item)
                flattenItem.forEach(n =>{
                    res.push(n)
                })
            }else{
                res.push(item)
            }
        })

        return res
    }
    const arr2 = [1,2,[3,[4,5]],6]
    console.log("flattenDeep",flattenDeep(arr2))
    //数组深度扁平化 彻底拍平 多维数组转为一维数组
    //使用concat
    function flattenDeep1(arr){
        let res  = []
        arr.forEach(item =>{
            if (Array.isArray(item)){
                const flattenItem =  flattenDeep1(item)
                res = res.concat(flattenItem)
            }else{
                res = res.concat(item)
            }
        })

        return res
    }
    const arr3 = [1,2,[3,[4,5]],6]
    console.log("flattenDeep1",flattenDeep1(arr3))

    //获取详细的数据类型
    function getType(x){
        const originType = Object.prototype.toString.call(x)
        const sliceIndex = originType.indexOf(' ')
        const type = originType.slice(sliceIndex+1 , -1)
        return type.toLowerCase()
    }

    console.log('getType',getType([]))


    //手写new
    //泛型  myNew<T> 定义什么类型就要返回什么类型
    function myNew(constrc,...arg) {
        let obj = Object.create(constrc.prototype)//创建空对象并把空对象的__proto__指向构造函数的原型对象
        let res = constrc.apply(obj,arg)// 改变constrc中this的指向并执行
        console.log('res instanceof Object',res,res instanceof Object,obj)
        //如果构造函数返回的是对象，则使用构造函数执行的结果。否则，返回新创建的对象
        return  res instanceof Object ?res:obj
    }

    function Foo(name,age){
        this.name =  name
        this.age = age
        // const num  = {}
        // return num
    }
    let f = myNew(Foo,'xiaoming',18)
    // let f = new Foo('xiaoming',18)
    console.log("myNew",f)

    //深度优先遍历dom树
    //访问节点
    function visitNode(n){
        if (n instanceof Comment ){
            //注释
            console.log('Comment',n.textContent)
        }
        if (n instanceof Text ){
            //注释
            if (n.textContent?.trim() !== ''){
                console.log('Text',n.textContent?.trim())
            }
        }
        if (n instanceof HTMLElement ){
            //注释
            console.log('HTMLElement', `<${n.tagName.toLowerCase()}>`)
        }
    }
    //深度优先遍历 用递归
    function depthFirstTraverse(root){
        visitNode(root)
        const childNodes = root.childNodes
        //.childNodes获取的是元素的所有子node 包括元素 注释comment  文本text
        //.children只获取元素
        if (childNodes.length){
            childNodes.forEach(child => {
                depthFirstTraverse(child)
            })
        }
    }
    const box = document.getElementById('box')
    // depthFirstTraverse(box)

    //深度优先遍历 用栈
    function depthFirstTraverse1(root){
        //定义一个栈 根节点压栈
        //while循环条件栈的长度大于零 出栈 如果出栈的节点等于null就break  访问出栈节点
        //如果出栈节点有子节点 就把子节点顺序反过来压栈
        const stack = []
        stack.push(root)
        while (stack.length > 0){
            const curNode = stack.pop()
            if (curNode == null) break
            visitNode(curNode)
            const childNodes = curNode.childNodes
            if (childNodes.length){
                Array.from(childNodes).reverse().forEach(child =>{
                    stack.push(child)
                })
            }
        }

    }
    depthFirstTraverse1(box)

    //广度优先 用队列
    function breadthFirstTraverse(root){
        //1 用数组来定义队列  根节点入队
        //2 while循环条件 队列长度大于0 就出队一个并且访问 如果出队的节点有子节点，就把子节点全部入队
        const queue = []
        queue.unshift(root)
        while (queue.length > 0){
            let curNode = queue.pop()
            if (curNode == null) break
            visitNode(curNode)
            const childNodes = curNode.childNodes
            if (childNodes.length){
                childNodes.forEach(child => queue.unshift(child))
            }
        }
    }
    // breadthFirstTraverse(box)



</script>

</html>
